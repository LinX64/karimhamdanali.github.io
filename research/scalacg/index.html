---
layout: page
title: scalacg
permalink: /research/scalacg/
tags: research
---

<div class="home">
	<h2>Overview</h2>
	<p>
		As Scala gains popularity, there is growing interest in programming tools for it. Such tools often require call 
		graphs. Applying existing call graph construction algorithms to the JVM bytecodes generated by the Scala 
		compiler produces imprecise results due to type information being lost during compilation. Therefore, we propose
		adapting existing call graph construction algorithms, Name-Based Resolution (RA) and Rapid Type Analysis (RTA), 
		for Scala. We have implemented 5 algorithms: RA, TCA<sup><i>names</i></sup>, TCA<sup><i>bounds</i></sup>, 
		TCA<sup><i>expand</i></sup>, and TCA<sup><i>expand-this</i></sup>. The algorithms are implemented as a Scala 
		compiler plugin. Our experimental evaluation shows that handling of complex Scala constructs, e.g., traits and 
		abstract type members, greatly improves the precision of the constructed call graphs. For more details on the 
		algorithms, and a formal proof of soundness, please refer to our 
		<a href="{{ "/resources/pubs/confs/ecoop14.pdf" |  prepend: site.baseurl }}" target="_blank">ECOOP'14 paper</a>.
	</p>
	
	<h2>Downloads</h2>
	<p>
		<ul>
			<li>
				<a href="{{ "/resources/scalacg/scalabench.tar.gz" |  prepend: site.baseurl }}">scalabench.tar.gz</a>: a self contained tarball 
				that include all the necessary scripts, runnable JARs, required to replicate our experiments.
			</li>
			<li>
				<a href="{{ "/resources/scalacg/scalacg.tar.gz" |  prepend: site.baseurl }}">scalacg.tar.gz</a>: the source code of our Scala 
				compiler plugin. This tarball contains the source code of the implementation of all our algorithms, and 
				RTA<sup>wala</sup>. Additionally, it comes with two test suites: one for TCA-based algorithms, and 
				another one for RA. The source code can be imported as an Eclipse Scala project (Note: you need the 
				<a href="http://scala-ide.org/download/current.html" target="_blank">Scala-IDE plugin</a> for Eclipse 
				to properly identify this Scala project). 
			</li>
			<li>
				<a href="{{ "/resources/scalacg/callgraph-plugin.jar" |  prepend: site.baseurl }}">callgraph-plugin.jar</a>: the Scala compiler 
				plugin that contains the implementation of our algorithms. Additionally, it contains the 
				<a href="http://plg.uwaterloo.ca/~olhotak/probe/schemas/callgraph.html" target="_blank">ProBe</a> tool 
				that we use to compare and output call graphs. 
			</li>
			<li>
				<a href="{{ "/resources/scalacg/walacg.jar" |  prepend: site.baseurl }}">walacg.jar</a>: a runnable 
				JAR for the implementation of RTA<sup>wala</sup>.
			</li>
			<li>
				<a href="http://www.dropbox.com/s/f1hnxevcfqogtio/scalavm.ova" target="_blank">scalavm.ova</a>: a VirtualBox appliance 
				that is set up to replicate our experiments. It has scalabench.tar.gz available on the desktop. You do 
				not need to worry about any prerequisites if you are using this virtual machine. Admin username: aec, 
				password: ecoop14. 
			</li>
		</ul>
	</p>
	
	<h2>Prerequisites</h2>
	<p>
		These are the prerequisites for using our plugin with the Scala compiler.
		<ul>
			<li>
				<a href="http://www.scala-lang.org/files/archive/scala-2.10.2.tgz" target="_blank">Scala-2.10.2</a>, 
				the plugin will crash if another Scala version is used.   
			</li>
			<li>
				Set the environment variable $SCALA_HOME (%SCALA_HOME% on Windows) to the location where you extract 
				the Scala-2.10.2 tarball.
			</li>
			<li>
				Set the environment variable $PATH to $PATH:$SCALA_HOME/bin (%PATH%;%SCALA_HOME%\bin on Windows).
			</li>
			<li>
				Set the environment variable $JAVA_OPTS (%JAVA_OPTS% in Windows) to
				"-Xmx2g -XX:PermSize=512m -XX:MaxPermSize=512m". This will give a maximum of 2G of RAM for the plugin 
				to run. This should be enough for small programs, test cases. Increase the value of "-Xmx" if Java runs 
				out of memory. It is worth noting here that the provided virtual machine requires 16G of RAM, and has 
				the Java option "-Xmx" set to 12G.
			</li>
		</ul>
		Additional prerequisites should be satisfied if you would like to use scalabench.tar.gz to replicate our 
		experiments. You do not have to worry about these if you are using the scalavm.ova virtual machine provided above.
		<ul>
			<li>
				Bash: the scripts use the Bash Unix shell to execute.
			</li>
			<li>
				Ant: please refer to the <a href="http://ant.apache.org/manual/install.html" target="_blank"> official 
				installation instructions</a> to install ant on your machine. 
			</li>
			<li>
				Set the environment variable $ANT_OPTS to $JAVA_OPTS. If Java runs out of memory, adjust the 
				environment variable $JAVA_OPTS accordingly. 
			</li>
			<li>
				walacg.jar includes a file named wala.properties that provides WALA with the location of the Java 
				runtime directory. It's set by default to /usr/lib/jvm/default-java/jre/lib. If the Java runtime 
				directory on your machine is different from this, then you need to update this file with the correct 
				path. You can either, edit the file inside the walacg.jar archive directly, or create an empty file 
				with the name wala.properties at the same directory of walacg.jar. Then, set the property 
				"java_runtime_dir" in it to the Java runtime directory on your system. You then need to run the 
				following command to update the properties file inside walacg.jar
				{% highlight bash %}
					$ jar uf walacg.jar wala.properties
				{% endhighlight %}
			</li>
			<li>
				LaTeX: <b>this is only required if you would like to get a PDF output of our experimental results </b>. 
				The scripts used to replicate our experiments generate the output data in CSV format as well (tab 
				separated). If you use LaTeX, please make sure you have the following LaTeX packages installed: 
				<a href="http://ctan.org/pkg/authblk" target="_blank">authblk</a>, 
				<a href="http://ctan.org/pkg/fullpage" target="_blank">fullpage</a>, and 
				<a href="http://ctan.org/pkg/multirow" target="_blank">multirow</a>.
			</li>
		</ul>
	</p>
	
	<h2>Usage</h2>
	<p>
		You can use our call-graph plugin to compile Scala code as follows, where &lt;analysis&gt; can be any value of: 
		ra, tca-names, tca-bounds, tca-expand, or tca-expand-this, and defaults to tca-expand-this.
		{% highlight bash %}
			$ scalac -cp callgraph-plugin.jar -Xplugin:callgraph-plugin.jar [-P:callgraph:<analysis>] <code.scala>
		{% endhighlight %}
	</p>
	<p>
		The plugin will output the call graph in a file named callgraph.txt.gzip, along with a summary call graph 
		(i.e., ignoring the edges within the library dependencies) in a file with the name callgraph-summary.txt.gzip. 
		Both files can be viewed and queried by the ProBe tool included in callgraph-plugin.jar. To print out the edges 
		of the call graph, run the following command:
		{% highlight bash %}
			$ java -cp callgraph-plugin.jar probe.CallGraphInfo callgraph.txt.gzip
		{% endhighlight %}
		For more information on how to use ProBe, please refer to 
		<a href="http://plg.uwaterloo.ca/~olhotak/probe/schemas/callgraph.html" target="_blank">this page</a>.
	</p>
	
	<h2>Replicating our experiments</h2>
	<p>
		You can either download the virtual machine, or download the tarball scalabench.tar.gz (both in the downloads 
		section above) and then satisfy all the prerequisites. The following tutorial does not depend on which path 
		you decide to take.
	</p>
	<p>
		You can run all analyses for one of our benchmark programs (see <a href="#bench">below</a>) by executing the 
		following commands:
		{% highlight bash %}
			$ cd <scalabench.tar.gz_extracted_location>
			$ ./run <benchmark_name>
		{% endhighlight %}
		This will run each of our algorithms, RTA<sup>wala</sup>, and the regular Scala compiler on the given benchmark. 
		The output of the plugin will be organized in sub-folders of scalabench, following the pattern: 
		scalabench/dist/&lt;analysis_name&gt;/&lt;benchmark_name&gt;.
	</p>
	<p>
		If you would like to run all analyses for all benchmark programs at once, you can use the scripts provided in 
		scalabench.tar.gz as follows:
		{% highlight bash %}
			$ cd <scalabench.tar.gz_extracted_location>
			$ ./run-all
		{% endhighlight %}
		If the script crashes due to memory-related issues, please set the environment variable $JAVA_OPTS with a 
		higher value for the -Xmx option. If everything goes well, this process can take ~ 4.5 hours. So it might be a 
		good idea to grab a cup of coffee, read a book, or attend to other items on your agenda while the scripts 
		finish running. The output of the script is organized in a similar fashion to analyzing just one benchmark. 
		Next, the script checks if the generated call graphs satisfy the following sanity check: <br />
		TCA<sup>expand-this</sup> &sube; TCA<sup>expand</sup> &sube; TCA<sup>bounds</sup> &sube; TCA<sup>names</sup> &sube; RA.
	</p>
	<p>
		Finally, the script generates the data we present in our 
		<a href="{{ "/resources/pubs/confs/ecoop14.pdf" |  prepend: site.baseurl }}" target="_blank">ECOOP'14 paper</a>
		in both CSV format (under scalabench/csv) and LaTeX format (under scalabench/tex). If you have LaTeX installed, 
		run the following script and the resulting PDF will be at scalabench/Results.pdf
		{% highlight bash %}
			$ cd <scalabench.tar.gz_extracted_location>
			$ ./makelatex
		{% endhighlight %}
	</p>
	
	<h2 id="bench">Benchmark programs</h2>
	<table>
		<thead>
			<tr>
				<th style="text-align:left">Program</th>
				<th style="text-align:left">Description</th>
				<th style="text-align:left">Source</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td class="sc">argot</td>
				<td>a command-line parser for Scala</td>
				<td><a href="http://github.com/bmc/argot" target="_blank">http://github.com/bmc/argot</a></td>
			</tr>
			<tr>
				<td class="sc">ensime</td>
				<td>a Scala Interaction Mode for Emacs</td>
				<td><a href="http://github.com/aemoncannon/ensime" target="_blank">http://github.com/aemoncannon/ensime</a></td>
			</tr>
			<tr>
				<td class="sc">fimpp</td>
				<td>an interpreter for FIM++</td>
				<td><a href="http://github.com/KarolS/fimpp" target="_blank">http://github.com/KarolS/fimpp</a></td>
			</tr>
			<tr>
				<td class="sc">kiama</td>
				<td>a Scala library for language processing</td>
				<td><a href="http://code.google.com/p/kiama" target="_blank">http://code.google.com/p/kiama</a></td>
			</tr>
			<tr>
				<td class="sc">phantm</td>
				<td>a static analyzer for PHP applications</td>
				<td><a href="http://github.com/colder/phantm" target="_blank">http://github.com/colder/phantm</a></td>
			</tr>
			<tr>
				<td class="sc">scalaxb</td>
				<td>an XML data-binding tool for Scala</td>
				<td><a href="http://github.com/eed3si9n/scalaxb" target="_blank">http://github.com/eed3si9n/scalaxb</a></td>
			</tr>
			<tr>
				<td class="sc">scalisp</td>
				<td>a LISP interpreter written in Scala</td>
				<td><a href="http://github.com/Mononofu/Scalisp" target="_blank">http://github.com/Mononofu/Scalisp</a></td>
			</tr>
			<tr>
				<td class="sc">see</td>
				<td>a Scala arithmetic expression engine</td>
				<td><a href="http://scee.sourceforge.net" target="_blank">http://scee.sourceforge.net</a></td>
			</tr>
			<tr>
				<td class="sc">squeryl</td>
				<td>a Scala ORM and DSL for SQL databases</td>
				<td><a href="http://github.com/max-l/Squeryl" target="_blank">http://github.com/max-l/Squeryl</a></td>
			</tr>
			<tr>
				<td class="sc">tictactoe</td>
				<td>the classic "tic-tac-toe" game</td>
				<td><a href="http://github.com/nickknw/arbitrarily-sized-tic-tac-toe" target="_blank">http://github.com/nickknw/arbitrarily-sized-tic-tac-toe</a></td>
			</tr>
		</tbody>
	</table>
</div>
